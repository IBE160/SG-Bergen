# Test Framework Architecture

This document provides an overview of the test framework for the Gjett Hvem? project. It uses Playwright for end-to-end testing, providing a robust and scalable solution for ensuring application quality.

## 1. Setup Instructions

### Prerequisites

- [Node.js](https://nodejs.org/) (version specified in `.nvmrc`)
- An instance of the application running locally or a deployed environment.

### Installation

1.  **Install Dependencies**: From the root of the project, run:
    ```bash
    npm install
    ```

2.  **Install Playwright Browsers**:
    ```bash
    npx playwright install --with-deps
    ```

3.  **Configure Environment**:
    - Copy the `.env.example` file to a new file named `.env`.
      ```bash
      cp .env.example .env
      ```
    - Edit the `.env` file with the correct values for your local or testing environment.

      ```bash
      # .env
      TEST_ENV=local
      BASE_URL=http://localhost:5173 # Assuming Vite's default port for the frontend
      API_URL=http://localhost:8000/api # Assuming FastAPI's default port

      # ... other variables
      ```

## 2. Running Tests

### Local Execution

- **Run all E2E tests (headless):**
  ```bash
  npm run test:e2e
  ```

- **Run tests with the Playwright UI (headed mode):**
  ```bash
  npm run test:e2e:ui
  ```

- **Run a specific test file:**
  ```bash
  npm run test:e2e -- tests/e2e/example.spec.ts
  ```

- **View the HTML report:**
  After running tests, a report is generated. View it with:
  ```bash
  npm run test:e2e:report
  ```

### Debugging

- Use the `--debug` flag to open the Playwright Inspector for step-by-step debugging.
  ```bash
  npm run test:e2e -- --debug
  ```

## 3. Architecture Overview

This framework is built on a set of best practices to ensure tests are maintainable, scalable, and resilient.

### Fixture Architecture

- We use a composable fixture model, defined in `tests/support/fixtures/index.ts`.
- Fixtures provide test contexts like data factories (`userFactory`) or authenticated states.
- This pattern promotes reuse and composition over inheritance, making tests cleaner and easier to maintain.
- **Reference**: `fixture-architecture.md`

### Data Factories

- Test data is generated dynamically using factories located in `tests/support/fixtures/factories/`.
- We use `@faker-js/faker` to create realistic, unique data for each test run, which is crucial for test isolation and parallel execution.
- Factories are responsible for their own data creation and cleanup, ensuring tests are atomic.
- **Reference**: `data-factories.md`

### Selector Strategy

- **`data-testid` is the standard.** All interactive elements in the application should have a `data-testid` attribute for stable test automation.
- **Avoid brittle selectors** like CSS classes or complex XPath. Rely on user-visible information like ARIA roles and text content as a fallback.
- **Reference**: `selector-resilience.md`

## 4. Best Practices

- **Test Isolation**: Each test file and each test case should be able to run independently without relying on the state of others. Use `beforeEach` and `afterEach` hooks for setup and teardown. The provided `userFactory` includes an automatic `cleanup` method.
- **Network-First**: Always register network interceptions (`page.waitForResponse`, `page.route`) *before* the action that triggers the request. This avoids race conditions and flaky tests.
- **Failure Artifacts**: The framework is configured to capture screenshots, videos, and traces *only on failure*. This provides maximum debugging information with minimal overhead for successful runs.

## 5. CI/CD Integration

- The `playwright.config.ts` is configured to run tests in parallel.
- In a CI environment (`process.env.CI` is true), tests will automatically retry on failure to account for flakiness.
- JUnit and HTML reports are generated and can be archived as build artifacts. See `test-results/`.
- **Reference**: `ci-burn-in.md` and `playwright-config.md`.

---
*This document was auto-generated by the TEA (`testarch-framework`) workflow.*
